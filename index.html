<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WDD130 Home Page</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }
        
        canvas {
            display: block;
            background-color: black;
        }
    </style>
</head>
<body>
    <canvas id="sandCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('sandCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            const tempGrid = grid;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            cols = Math.floor(canvas.width / pixelSize);
            rows = Math.floor(canvas.height / pixelSize);

            grid = createGrid();

            const minCols = Math.min(tempGrid.length, cols);
            const minRows = Math.min(tempGrid[0] ? tempGrid[0].length : 0, rows);
            
            for (let i = 0; i < minCols; i++) {
                for (let j = 0; j < minRows; j++) {
                    grid[i][j] = tempGrid[i][j];
                }
            }
        });

        const pixelSize = 4;
        let cols = Math.floor(canvas.width / pixelSize);
        let rows = Math.floor(canvas.height / pixelSize);

        let grid = createGrid();

        function createGrid() {
            const grid = [];
            for (let i = 0; i < cols; i++) {
                grid[i] = [];
                for (let j = 0; j < rows; j++) {
                    grid[i][j] = 0;
                }
            }
            return grid;
        }

        function update() {

            const newGrid = grid.map(arr => [...arr]);
            
            for (let i = cols - 1; i >= 0; i--) {
                for (let j = rows - 1; j >= 0; j--) {
                    if (grid[i][j] !== 1) continue;

                    if (j < rows - 1 && grid[i][j + 1] === 0) {
                        newGrid[i][j] = 0;
                        newGrid[i][j + 1] = 1;
                    } 

                    else if (j < rows - 1) {
                        const direction = Math.random() > 0.5 ? -1 : 1;
                        if (i + direction >= 0 && i + direction < cols && 
                            grid[i + direction][j + 1] === 0) {
                            newGrid[i][j] = 0;
                            newGrid[i + direction][j + 1] = 1;
                        }
                    }
                }
            }

            grid = newGrid;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#e6c88c';
            
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (grid[i][j] === 1) {
                        ctx.fillRect(i * pixelSize, j * pixelSize, pixelSize, pixelSize);
                    }
                }
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();

        let isDrawing = false;
        
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: Math.floor((evt.clientX - rect.left) / pixelSize),
                y: Math.floor((evt.clientY - rect.top) / pixelSize)
            };
        }
        
        function addSand(x, y) {

            for (let i = -2; i <= 2; i++) {
                for (let j = -2; j <= 2; j++) {
                    const posX = x + i;
                    const posY = y + j;
                    if (posX >= 0 && posX < cols && posY >= 0 && posY < rows) {
                        if (i*i + j*j <= 4) {
                            grid[posX][posY] = 1;
                        }
                    }
                }
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const pos = getMousePos(canvas, e);
            addSand(pos.x, pos.y);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const pos = getMousePos(canvas, e);
            addSand(pos.x, pos.y);
        });
        
        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            const touch = e.touches[0];
            const pos = getMousePos(canvas, touch);
            addSand(pos.x, pos.y);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDrawing) return;
            const touch = e.touches[0];
            const pos = getMousePos(canvas, touch);
            addSand(pos.x, pos.y);
        });
        
        canvas.addEventListener('touchend', () => {
            isDrawing = false;
        });
    </script>
</body>
</html>